***************************************************************
** 各種レジスタ定義 
***************************************************************

***************
** レジスタ群の先頭 
***************
.equ REGBASE,	0xFFF000 	| 内部デバイス (DMAP) のベースアドレス
.equ IOBASE,	0x00d00000	| 外部 I/O (LEDなど) のベースアドレス

***************
** 割り込み関係のレジスタ 
***************
.equ IVR, 	REGBASE+0x300 	| 割り込みベクタレジスタ: ユーザー割り込みベクタのベース設定に使用
.equ IMR, 	REGBASE+0x304 	| 割り込みマスクレジスタ: 許可/禁止する割り込みレベルを設定
.equ ISR, 	REGBASE+0x30c 	| 割り込みステータスレジスタ
.equ IPR,	REGBASE+0x310 	| 割り込みペンディングレジスタ

***************
** タイマ関係のレジスタ 
***************
.equ TCTL1,	REGBASE+0x600 	| タイマ１コントロールレジスタ: 動作モードや割り込み許可などを設定
.equ TPRER1, 	REGBASE+0x602 	| タイマ１プリスケーラレジスタ: クロック分周比を設定
.equ TCMP1, 	REGBASE+0x604 	| タイマ１コンペアレジスタ: カウンタと比較し、一致で割り込み発生
.equ TCN1, 	REGBASE+0x608 	| タイマ１カウンタレジスタ
.equ TSTAT1, 	REGBASE+0x60a 	| タイマ１ステータスレジスタ: 割り込み発生フラグなどを保持

***************
** UART1（送受信）関係のレジスタ 
***************
.equ USTCNT1, 	REGBASE+0x900 	| UART1 ステータス/コントロールレジスタ: モード設定や送受信割り込み制御
.equ UBAUD1, 	REGBASE+0x902 	| UART1 ボーコントロールレジスタ: 通信速度を設定
.equ URX1, 	REGBASE+0x904 	| UART1 受信レジスタ: 受信データ格納、読み出しで受信割り込みクリア
.equ UTX1, 	REGBASE+0x906 	| UART1 送信レジスタ: 送信データ格納、書き込みで送信開始

***************
** LED (ボード搭載の外部I/O)
***************
.equ LED7, 	IOBASE+0x000002f
.equ LED6, 	IOBASE+0x000002d
.equ LED5, 	IOBASE+0x000002b
.equ LED4, 	IOBASE+0x0000029
.equ LED3, 	IOBASE+0x000003f
.equ LED2, 	IOBASE+0x000003d
.equ LED1, 	IOBASE+0x000003b
.equ LED0, 	IOBASE+0x0000039

***************
**システムコール番号
***************
.equ	SYSCALL_NUM_GETSTRING,     1	| 文字列受信システムコール
.equ	SYSCALL_NUM_PUTSTRING,     2	| 文字列送信システムコール
.equ	SYSCALL_NUM_RESET_TIMER,   3	| タイマ停止・リセットシステムコール
.equ	SYSCALL_NUM_SET_TIMER,     4	| タイマ設定・起動システムコール

***************************************************************
** スタック領域の確保 
***************************************************************
.section .bss
.even
SYS_STK:
	.ds.b 	0x4000 	| システムスタック領域 (スーパバイザモード用)
	.even 
SYS_STK_TOP: 		| システムスタック領域の最後尾 (スタックポインタ初期値)

task_p: .ds.l 	1	| タイマ割り込み時に起動するルーチンのアドレス格納用 (大域変数)

******************************
** キュー用のメモリ領域確保 (2つのキューを連続して確保)
******************************
.equ	B_SIZE, 256	| キューのバッファサイズ
/* キュー0 (受信キューとして使用) */
TOP:	.ds.b	B_SIZE-1	| キューのバッファ開始アドレス
BOTTOM: .ds.b	1		| キューのバッファ終了アドレスの次
IN:	.ds.l	1		| 書き込みポインタ (次に書き込むアドレス)
OUT:	.ds.l	1		| 読み出しポインタ (次に読み出すアドレス)
S:	.ds.l	1		| キューに格納されているデータ数 (サイズ)

/* キュー1 (送信キューとして使用) - TOPから0x10cバイト離れた位置に配置される */
TOP1:	.ds.b	B_SIZE-1
BOTTOM1: .ds.b	1
IN1:	.ds.l	1
OUT1:	.ds.l	1
S1:	.ds.l	1


***************************************************************
** 初期化 
***************************************************************
.section .text
.even
boot: 
	/* ** スーパーバイザ & 各種設定を行っている最中の割込禁止 ** */
	move.w 	#0x2700,%SR 	| SR (Status Register) 設定:
					| Sビット=1 (スーパーバイザモード), 
					| 割り込みマスクレベル=7 (全割り込み禁止)
	lea.l 	SYS_STK_TOP, %SP 	| SSP (スーパーバイザスタックポインタ) を設定

	****************
	** 割り込みコントローラの初期化 
	****************
	move.b 	#0x40, IVR 		| ユーザ割り込みベクタ番号を
					| 0x40+level*4 に設定 (オートベクタ以外)
	move.l 	#0x00ffffff,IMR 	| 全割り込みマスク (IMRの1ビットが1でマスク)


	****************
	** 送受信 (UART1) 関係の初期化 (割り込みレベルは 4 に固定されている)
	****************
	move.w 	#0x0000, USTCNT1 	| リセット
	move.w 	#0xe100, USTCNT1 	| モード設定: 送受信可能, パリティなし, 1 stop, 8 bit,
					| 送受割り込み禁止 (E100 = 1110 0001 0000 0000)
	move.w 	#0x0038, UBAUD1 	| baud rate = 230400 bps に設定 (クロック周波数に基づく値)


	****************
	** タイマ関係の初期化 (割り込みレベルは 6 に固定されている) 
	*****************
	move.w 	#0x0004, TCTL1 		| restart (リスタート可), 割り込み不可, 
					| システムクロックの 1/16 を単位として計時，
					| タイマ使用停止

	*****************
	**割り込みベクタの初期化 (68k のベクタテーブルにハンドラアドレスを設定)
	***************
	/* trap#0命令 (システムコール) のハンドラアドレス設定 (ベクタ番号 32*4 = 0x080) */
	move.l	#systemcall, 0x080

	/* 送受信割り込みのハンドラアドレス設定 (ベクタ番号 64+4 = 68*4 = 0x110) */
	move.l 	#uart1_interrupt, 0x110 	| レベル4のオートベクタに対応 

	/* タイマ割り込みのハンドラアドレス設定 (ベクタ番号 64+6 = 70*4 = 0x118) */
	move.l 	#timer_interrupt, 0x118 	| レベル6のオートベクタに対応
	
	*****************
	**本実験では使用しない割り込みベクタの初期化 (デッドループ回避のため RTE を設定)
	move.l	#LV1, 0x104		| レベル1
	move.l	#LV2, 0x108		| レベル2
	move.l	#LV3, 0x10c		| レベル3
	move.l	#LV5, 0x114		| レベル5
	move.l	#LV7, 0x11c		| レベル7


	/* 割り込みマスクレジスタ設定 */
	move.l	#0xff3ff9, IMR			| UART1割り込み (レベル4),Timer1割り込み (レベル6) を許可
						| (該当ビットが0で許可)
	/* USTCNT1 レジスタで受信許可, 送信禁止 */
	move.w	#0xe108, USTCNT1		| 受信割り込みを許可 (1110 0001 0000 1000)

	jsr INIT_Q				| 受信/送信キューの初期化

	
	/* 初期化が全て終わったら割り込みを許可する */
	**走行レベルを0にする
	move.w	#0x2000,%SR    			| 割り込み許可: Sビット=1 (スーパーバイザモード), 
						| 割り込みマスクレベル=0 (全レベルの割り込みを受け付け)

	bra 	MAIN

**初期化終了
***************************************************************

---

### 割り込みハンドラ

```assembly
***************************************************************
**送受信用HW割り込みインタフェース (レベル4)
***************************************************************
uart1_interrupt:
	movem.l %d1-%d3,-(%SP)		| D1-D3 レジスタをスタックに退避

**送信用HW割り込みインターフェース
	move.w	UTX1,%d2		| UTX1 (送信レジスタ) のステータスをコピー
	cmp	#0x8000,%d2		| d2の15ビット目 (送信可能フラグ) が1かどうか判別
	bcs	Interface_get		| 15ビット目が0 (送信準備中/キュー空) なら受信チェックへ

	/* 15bitが1なら送信バッファ空き -> 送信割り込み処理を行う */
	moveq.l	#0,%d1			| ch=%D1.L=0 (未使用、INTERPUT側でキュー1を見る)
	jsr	INTERPUT		| キューからデータを取り出し、UTX1へ書き込む

**受信用HW割り込みインタフェース
Interface_get:
	move.w	URX1,%d3		| 受信レジスタURX1を%D3.Wにコピー (データ + ステータス)
	move.b	%d3,%d2			| D3.Wの下位8bit(データ部分)を%D2.Bにコピー
	cmp	#0x2000,%d3		| d3の13ビット目 (受信データありフラグ) を判別
	bcs	uart1_interrupt_end	| 13bitが0 (データなし) なら割り込み終了へ

	/* 13bitが1なら受信データあり -> 受信割り込み処理を行う */
	moveq.l	#0,%d1			| チャンネルch = %D1.L =0 (UART1)
	jsr	INTERGET		| 受信データ (%d2.b) を受信キューへ格納

uart1_interrupt_end:
	movem.l (%SP)+, %d1-%d3		| 退避したレジスタを復帰
	move.w #0x2000,%SR		| SRを復帰 (割り込みマスクレベル0)
	rte				| 割り込み終了 (Return from Exception)

******************************************************************
**タイマ用HW割り込みインタフェース (レベル6)
******************************************************************
timer_interrupt:
	movem.l %d1/%a0,-(%SP)		| D1, A0 レジスタをスタックに退避
	move	%SR,-(%SP)		| SRをスタックに退避

	move.w	TSTAT1,%d1		| タイマステータスレジスタを読み出し
	cmpi	#0x0002, %d1		| TSTAT1の1ビット目 (カウンタオーバフロー) が1か判別
	beq	timer_interrupt_end	| 1なら処理せず終了 (今回は未使用のフラグ)

	cmpi	#0x0000, %d1		| TSTAT1の0ビット目 (カウンタコンペア一致) が1か判別
						| (0ビット目が1の時、TSTAT1は 0x0001 または 0x0003 となる)
	beq	timer_interrupt_end	| 0なら処理せず終了

	/* 0ビット目が1のとき -> コンペア一致割り込みが発生 */
	move.w	#0x0000,TSTAT1		| TSTAT1を0クリア (割り込みフラグをリセット)
	jsr	CALL_RP			| 大域変数 task_p に設定されたルーチンを呼び出し

timer_interrupt_end:
	move	(%SP)+,%SR		| 退避したSRを復帰
	movem.l (%SP)+, %d1/%a0		| 退避したD1, A0を復帰
	rte				| 割り込み終了

******************************************************************
**システムコールインタフェース (trap #0)
******************************************************************
systemcall:
	/* D0レジスタのシステムコール番号を判別 */
	cmp	#1,%d0
	beq	GO_GETSTRING		| D0=1 なら GETSTRINGへ
	cmp	#2,%d0
	beq	GO_PUTSTRING		| D0=2 なら PUTSTRINGへ
	cmp	#3,%d0
	beq	GO_RESET_TIMER		| D0=3 なら RESET_TIMERへ
	cmp	#4,%d0
	beq	GO_SET_TIMER		| D0=4 なら SET_TIMERへ
	bra	systemcall_end		| 該当なし

GO_GETSTRING:
	jsr	GETSTRING
	bra	systemcall_end
GO_PUTSTRING:
	jsr	PUTSTRING
	bra	systemcall_end
GO_RESET_TIMER:
	jsr	RESET_TIMER
	bra	systemcall_end
GO_SET_TIMER:
	jsr	SET_TIMER
	bra	systemcall_end

systemcall_end:
	rte				| 処理を終えてユーザーモードに戻る

****************************
**使用しない割り込みルーチン
****************************
LV1:	rte
LV2:	rte
LV3:	rte
LV5:	rte
LV7:	rte

---

### キュー/I/O サブルーチン

```assembly
******************************************************************
**サブルーチン
******************************************************************

**********************
** キューの初期化処理
**********************
INIT_Q:
	/* キュー0 (受信) の初期化 */
	lea.l	TOP,%a2			| キューバッファの先頭アドレスをA2に
	move.l	%a2,IN			| INポインタを先頭に
	move.l	%a2,OUT			| OUTポインタを先頭に
	move.l	#0x00,S			| データ数を0に
	
	/* キュー1 (送信) の初期化 */
	add	#0x10c,%a2		| TOPからオフセット 0x10c を加算 (キュー1の先頭アドレスへ)
	move.l	%a2,IN1			| IN1ポインタを先頭に
	move.l	%a2,OUT1		| OUT1ポインタを先頭に
	move.l	#0x00,S1		| データ数を0に
	rts

********************
** InQ キューへのデータ書き込み (キュー番号はD0レジスタで指定)
** d0:キュー番号 (入力)、結果(00:失敗, 01:成功) (出力)
** d1:書き込むデータ (入力)
***********************************
INQ:
	jsr	PUT_BUF			| 共通のキュー書き込みサブルーチンへ
	rts

***************************************
** PUT_BUF (環状バッファへの書き込み)
** d0:成功失敗の出力、キュー番号の入力 (0または1)
** d1:書き込むバイトデータ
****************************************
PUT_BUF:
	movem.l	%a1-%a5/%d2-%d5,-(%sp)	| レジスタ退避 
	move	%SR,-(%sp)		| SR (走行レベル) 退避

	move.w	#0x2700,%SR		| 割り込みの禁止 (排他制御) 
	move.l  %d0,%d5			| D0 (キュー番号) をD5にコピー
	mulu	#0x010c, %d5		| D5 * 0x10c でオフセット計算 (キュー0とキュー1のメモリ間隔)
	
	/* キューのサイズ S (データ数) をチェック */
	lea.l   S,%a4			| S (データ数カウンタ) のベースアドレスをA4に
	move.b  #0x00,%d0		| 出力D0を０（失敗）に初期化
	cmp.l   #0x0100, (%d5,%a4)	| S == 0x100 (B_SIZE) かチェック (キューが一杯)
	beq	PUT_BUF_Finish		| 一杯なら終了
	
	/* データ書き込み */
	lea.l   IN,%a5			| INポインタのベースアドレスをA5に
	movea.l (%d5,%a5),%a1		| INポインタ (A5 + オフセット) の値をA1に転送 (書き込み先アドレス)
	move.b  %d1,(%a1)+		| D1のデータをA1が指す場所へ書き込み、A1を1バイトインクリメント 
	
	/* 環状バッファのラップアラウンドチェック */
	lea.l   BOTTOM,%a3		| BOTTOM (バッファの終端アドレス) のベースアドレスをA3に
	add	%d5,%a3			| A3にオフセットを加算し、対象キューの終端アドレスを取得
	cmpa.l  %a3,%a1  		| A1 (新しいINポインタ) が終端 (A3) を超えたかチェック 
	bls	PUT_BUF_STEP1		| 超えていなければそのまま次へ
	
	/* 超えていたら先頭 (TOP) に戻す */
	lea.l   TOP,%a2			| TOP (バッファの先頭アドレス) のベースアドレスをA2に
	add	%d5,%a2			| A2にオフセットを加算
	movea.l %a2,%a1			| A1を先頭アドレスに設定

PUT_BUF_STEP1:
	move.l  %a1,(%d5,%a5)		| 1バイト分ずらしたアドレスをINポインタに書き戻す 

PUT_BUF_STEP2:
	move.b	#0x01,%d0		| 出力D0を01(成功)にする 
	addq.l	#1,(%d5,%a4)		| データ数 S をインクリメント

PUT_BUF_Finish:
	move	(%sp)+,%SR		| 走行レベルの回復
 	movem.l (%sp)+,%a1-%a5/%d2-%d5	| レジスタの回復 
	rts

***********************************
** OUTQ キューからのデータ読み出し (キュー番号はD0レジスタで指定)
** d0:キュー番号 (入力)、結果(00:失敗, 01:成功) (出力)
** d1:読み出したデータ (出力)
***********************************
OUTQ:
	jsr	GET_BUF			| 共通のキュー読み出しサブルーチンへ 
	rts

***************************************
** GET_BUF (環状バッファからの読み出し)
** 機能：番号noのキューからデータを一つ取り出す
** 入力：キュー番号no →  %D0.L
** 出力：失敗0/成功1 →  %D0.L, 取り出した8bitデータ →  %D1.B
****************************************
GET_BUF:
	movem.l	%a1-%a5/%d2-%d5,-(%sp)	| レジスタ退避 
	move	%SR,-(%sp)		| 現走行レベルの退避 

 	move.w  #0x2700,%SR		| 割り込みの禁止 (排他制御) 
	move.l  %d0,%d5			| D0 (キュー番号) をD5にコピー
	mulu	#0x010c, %d5		| D5 * 0x10c でオフセット計算
	
	/* キューのサイズ S (データ数) をチェック */
	lea.l   S,%a4			| S (データ数カウンタ) のベースアドレスをA4に
	move.b  #0x00,%d0		| 出力D0を０（失敗）に初期化
	cmp.l   #0x000, (%d5,%a4)	| S == 0x000 かチェック (キューが空)
	beq	GET_BUF_Finish		| 空なら終了
	
	/* データ読み出し */
	lea.l   OUT,%a5			| OUTポインタのベースアドレスをA5に
 	movea.l (%d5,%a5),%a1		| OUTポインタの値をA1に転送 (読み出し元アドレス)
  	move.b  (%a1)+,%d1		| A1の指す場所からD1にデータを読み出し、A1を1バイトインクリメント 
  	
	/* 環状バッファのラップアラウンドチェック */
   	lea.l   BOTTOM,%a3		| BOTTOMのベースアドレスをA3に
   	add	%d5,%a3			| 対象キューの終端アドレスを取得
   	cmpa.l  %a3,%a1			| A1 (新しいOUTポインタ) が終端 (A3) を超えたかチェック 
  	bls	GET_BUF_STEP1		| 超えていなければそのまま次へ
  	
	/* 超えていたら先頭 (TOP) に戻す */
   	lea.l   TOP,%a2			| TOPのベースアドレスをA2に
   	add	%d5,%a2			| A2にオフセットを加算
   	movea.l %a2,%a1			| A1を先頭アドレスに設定

GET_BUF_STEP1:
   	move.l  %a1,(%d5,%a5) 		| 1バイト分ずらしたアドレスをOUTポインタに書き戻す 

GET_BUF_STEP2:
   	move.b	#0x01,%d0		| 出力D0を１（成功）にする
   	subq.l	#1,(%d5,%a4)		| データ数 S をデクリメント

GET_BUF_Finish:
   	move	(%sp)+,%SR		| 走行レベルの回復
	movem.l (%sp)+,%a1-%a5/%d2-%d5 	| レジスタの回復 
	rts

***************************************************************
** UART1 送信データ処理 (送信割り込みハンドラから呼ばれる)
** 入力: d1.L = チャンネル番号 (常に0を期待)
***************************************************************
INTERPUT:
	move.w	#0x2700,%SR		| 割り込みの禁止 (排他制御)
	cmp.l	#0x00,%d1		| チャンネル番号が0 (UART1) か確認
	bne	INTERPUT_FINISH		| 0以外なら終了
	
	move.l	#1,%d0			| キュー番号1 (送信キュー) を選択
	jsr	OUTQ			| 送信キューから1バイト読み出し (%d1.bに格納)
	
	cmp	#0x00,%d0
	beq	INTERPUT_MASK		| 復帰値0ならキューが空 -> 送信マスクへ
	
	add	#0x0800, %d1  		| 送信データヘッダ 0x0800 を付与 (UTX1の仕様) 
	move.w	%d1, UTX1		| UTX1にデータを出力
	bra	INTERPUT_FINISH
INTERPUT_MASK:
	move.w	#0xE108, USTCNT1  	| 送信割り込みをマスク (受信は許可)

INTERPUT_FINISH:
	rts

*************************************************************
** UART1 受信データ処理 (受信割り込みハンドラから呼ばれる)
** 入力: d1.L = チャネル番号 (常に0を期待)
** d2.B = 受信データ
*************************************************************
INTERGET:
	movem.l %d0-%d1,-(%sp)  	| D0, D1 レジスタ退避 (D2は受信データとして使用するため退避しない)
	cmp.l   #0,%d1          	| チャネルが0 (UART1) か判定
	bne     INTERGET_FIN
	
	/* タイピングテスト用: 入力文字が期待される文字かチェック */
	move.b	(%a6),%d1		| A6 (期待される入力文字のポインタ) が指す文字をD1に格納

	cmp.b   %d1,%d2			| 受信したデータ (D2.B) が期待される文字 (D1.B) と一致するかチェック
	bne	INTERGET_FIN		| 不一致なら終了 (不正な入力はキューに入れない)
	
	/* 一致した場合、受信キューへ格納 */
	move.l  #0,%d0          	| キュー番号0 (受信キュー) を選択
	move.b  %d2,%d1         	| 受信データ (D2.B) をINQの引数D1.Bに移動
        jsr     INQ			| 受信キューへ格納
	
	add	#1,%a6          	| 期待文字列のポインタ (A6) を1バイトずらす
	addi.l	#1,COUNTER  		| 入力できた文字数 (COUNTER) をカウント
        
INTERGET_FIN:
	movem.l (%sp)+,%d0-%d1  	| レジスタ回復
	rts

******************************************************
**PUTSTRING (システムコール 2)
**入力　チャンネルー＞d1 (0を期待)
**　　　　データ読み込み先の先頭アドレス(p)ー＞d2
**　　　送信するデータサイズ(size)ー＞d3
**出力　実際に送信キューに入れたデータ数(sz)ー＞d0
******************************************************
PUTSTRING:
	movem.l	%a0/%d4,-(%sp)		| レジスタ退避
	cmp.l	#0x00,%d1		| CHが0 (UART1) か判別
        bne	PUTST_FIN2		| 0以外なら終了
	
	move.l	#0x00,%d4		| D4 (sz:送信文字数カウンタ) = 0
	movea.l	%d2, %a0		| A0＝p (送信元アドレス)
	cmp	#0x00,%d3 		| size=0なら終了
	beq	PUTST_FIN1	
PUTLOOP1:
	cmp.l	%d4,%d3			| sz=sizeなら終了
	beq	PUT_UNMASK
        move.l	#0x01,%d0		| INQの引数の設定: キュー番号1 (送信キュー)
        move.b	(%a0),%d1 		| 送信データ (%A0が指す文字) をD1.Bへ
	jsr	INQ			| 送信キューへ書き込み
	
	cmp	#0x00,%d0		| INQの復帰値が0なら (キューフル)
	beq	PUT_UNMASK		| キューがフルなら処理を中断し、送信割り込み許可へ
	
	add	#0x01,%d4		| sz++
	add	#0x01,%a0		| A0 (ポインタ) ++
	bra	PUTLOOP1
PUT_UNMASK:
	move.w	#0xE10E,USTCNT1		| 送信割り込みを許可 (E10E = 1110 0001 0000 1110)
PUTST_FIN1:
	move.l	%d4,%d0 		| D0にsz (実際にキューに入れた文字数) を設定
PUTST_FIN2:
	movem.l	(%sp)+,%a0/%d4		| レジスタ回復
        rts

****************************************************
**GETSTRING (システムコール 1)
**入力　チャネルch→%d1.L (0を期待)
**　　　データ書き込み先の先頭アドレス→%d2.L
**　　　取り出すデータ数 size→%d3.L
**(戻り値)実際に取り出したデータ数sz→%d0.L
****************************************************
GETSTRING:
	movem.l	%a0/%d4,-(%sp)		| レジスタ退避
	cmp.l	#0,%d1 			| チャネルが0 (UART1) か判定
	bne	GETST_FIN2		| 0以外なら終了

	move.l	#0,%d4		 	| D4 (sz:受信文字数カウンタ) = 0
	movea.l	%d2,%a0            	| A0に書き込み先の先頭アドレスを代入
GETST_LOOP:
	cmp.l	%d4,%d3            	| if sz=size →　FIN (指定された文字数に達した)
	beq	GETST_FIN1

	move.l	#0,%d0             	| 受信キュー (キュー番号0) を選択
	jsr	OUTQ			| 受信キューから1バイト読み出し (%d1.bに格納)
	cmp.l	#0,%d0     		| OUTQ失敗ならFIN (キューが空)
	beq	GETST_FIN1

	move.b	%d1,(%a0)		| D1 (読み出したデータ) をA0が指す場所へコピー
	add	#1,%d4   		| sz++
	add	#1,%a0   		| A0 (ポインタ) ++
	bra	GETST_LOOP
GETST_FIN1:
	move.l	%d4,%d0           	| D0にsz (実際に取り出した文字数) を設定
GETST_FIN2:
	movem.l	(%sp)+,%a0/%d4		| レジスタ回復
	rts


******************************************************************
**タイマサブルーチン (システムコール 3, 4 から呼ばれる)
******************************************************************
RESET_TIMER:
	move.w #0x0004, TCTL1	| タイマ使用停止 (4ビット目 = 0)
	rts

***************
SET_TIMER:
	/* 割り込み時に起動するルーチン先頭アドレスp (%d2.l) を大域変数task_pに格納 */
	move.l %d2, task_p 	
	
	/* TPRER1 の設定 (プリスケーラ) */
	move.w #0x00ce, TPRER1	| 0xCE = 206。0.1 msec 進むとカウンタが1増えるようにする
				| (システムクロックと TPRER1 の値で計時単位が決まる)
	
	/* タイマ割り込み発生周期t (%d1.w) をTCMP1に代入 (単位は0.1msec) */
	move.w %d1, TCMP1 	
	
	/* TCTL1 (コントロールレジスタ) の設定 */
	move.w #0x0015, TCTL1 	| restart (リスタート可), 割り込み許可 (5ビット目=1)
				| システムクロックの 1/16 を単位として計時
				| タイマ使用許可 (4ビット目=1)
	rts

***************
CALL_RP:
	move.l	(task_p),%a0	| 大域変数 task_p のアドレス (タスクルーチンの先頭) をA0に格納
	jsr (%a0) 		| A0が指すアドレス (TTルーチン) へジャンプ
	rts

---

### メインルーチンとタイピングテストタスク

```assembly
******************************************************************
**MAIN関数
******************************************************************
.section .text
.even
MAIN:
/* ** 走行モードとレベルの設定(「ユーザモード」への移行処理) ** */
	move.w	#0x0000, %SR		| ユーザーモード (Sビット=0), レベル 0
	lea.l	USR_STK_TOP,%SP		| ユーザーモードスタックポインタ (USP) を設定

/* ** システムコールによるタイマ初期設定 ** */
	/* 1. RESET_TIMER (タイマ停止) */
	move.l	#SYSCALL_NUM_RESET_TIMER,%D0
	trap	#0
	
	/* 2. SET_TIMER (タイマ設定・起動) */
	move.l	#SYSCALL_NUM_SET_TIMER, %D0
	move.w  #2000, %D1		| 2000 * 0.1msec = 200msec (初回起動時の周期設定)
	move.l	#TT,    %D2		| 起動するルーチンアドレスを TT に設定
	trap	#0

******************************
** sys_GETSTRING, sys_PUTSTRINGのテスト (エコーバック処理)
** ターミナルの入力をバッファに読み込み、そのまま出力する
******************************
LOOP:
	/* GETSTRING: 受信キューからデータを読み出し */
	move.l	#SYSCALL_NUM_GETSTRING, %D0
	move.l	#0,   %D1        	| ch = 0 (UART1)
	move.l	#BUF, %D2        	| p = #BUF (読み出し先バッファ)
	move.l	#256, %D3        	| size = 256 (最大読み出しバイト数)
	trap	#0			| 戻り値 %D0 に実際に読み出した文字数が入る

	/* PUTSTRING: 読み込んだデータをそのまま送信キューへ書き込み */
	move.l	%D0, %D3        	| size = %D0 (読み出した文字数) を設定
	move.l	#SYSCALL_NUM_PUTSTRING, %D0
	move.l	#0,  %D1         	| ch = 0 (UART1)
	move.l	#BUF,%D2         	| p  = #BUF (送信元バッファ)
	trap	#0

	bra	LOOP


**********************************************************
**　TT (Timer Task) : タイピング練習処理ルーチン
**　タイマ割り込みで定期的に実行され、表示・入力チェック・結果更新を行う
*********************************************************
TT:
	movem.l	%D0-%D7/%A0-%A5,-(%SP)	| 全レジスタ退避
	
	cmpi.l	#0, LEN_STR     	| 初回起動時 (LEN_STR=0) はスルー
	beq	TTC_BRA
	
	/* 前回表示した文字列の入力チェック */
	lea.l	COUNTER,%a4
	lea.l	LEN_STR,%a5
	move.l	(%a4),%d4		| D4 = COUNTER (入力できた文字数)
	move.l	(%a5),%d5		| D5 = LEN_STR (表示した文字列の長さ)
	cmp.l	%d4,%d5         	| LEN_STR - COUNTER (文字数が一致したか)
	beq     CORRECT_PLUS		| 一致 (時間内に全文字入力成功) なら成功カウントへ
	bra	MISS_PLUS            	| 不一致 (時間内に間に合わなかった) なら失敗カウントへ
	
TTC_BRA:
	cmpi.w	#9,TTC            	| TTCカウンタが9回 (全テスト終了) かどうか数える
	beq	TTKILL               	| 9回実行したらタイマを停止する
	
	move.l  #0, COUNTER          	| 文字数カウンターを初期化
	move.l	#SYSCALL_NUM_PUTSTRING,%D0 | PUTSTRING のシステムコール番号設定
	move.l	#0,    %D1        	| ch = 0 (UART1)
	
	/* TTCの値に応じて処理を分岐 */
	cmpi.w	#0,TTC                  | TTC == 0 ⇒ WD1 表示
	beq	RWD1
	cmpi.w	#1,TTC
	beq	RWD2
	cmpi.w	#2,TTC
	beq	RWD3
	cmpi.w	#3,TTC
	beq	RWD4
	cmpi.w	#4,TTC
	beq	RWD5
	cmpi.w	#5,TTC
	beq	CORRECT_OUT      	 | "correct: " の表示
	cmpi.w	#6,TTC
	beq	CORRECT_NUM      	 | CORRECT (正解数) の表示
	cmpi.w	#7,TTC
	beq	MISS_OUT            	 | "miss: " の表示
	cmpi.w	#8,TTC
	beq	MISS_NUM           	 | MISS (誤り数) の表示

RWD1:	/* WD1 (kyushudaigaku) の表示設定 */
	move.l	#WD1, %D2        	 | p  = #WD1 (送信元アドレス)
	move.l	#WD1, %a6		 | A6 (期待文字列ポインタ) も設定
	move.l	#0x11,   %D3        	 | size = 17 (文字列長+\r\n)
	move.l  #13, LEN_STR		 | 期待される入力文字数 (WD1の文字数)
	move.w  #50000, TCMP1 		 | 制限時間 (50000 * 0.1msec = 5秒)
	bra	TTCPLUS
RWD2:	/* WD2 (dennkijyouhoukougakuka) の表示設定 */
	move.l	#WD2, %D2        	 | p  = #WD2
	move.l	#WD2, %a6 
	move.l	#0x1a,    %D3        	 | size = 26
	move.l  #22, LEN_STR
	move.w  #60000, TCMP1 		 | 制限時間 (6秒)
	bra	TTCPLUS
RWD3:	/* WD3 (hyodo) の表示設定 */
	move.l	#WD3, %D2        	 | p  = #WD3
	move.l	#WD3, %a6
	move.l	#0x09,    %D3        	 | size = 9
	move.l  #5, LEN_STR
	move.w  #30000, TCMP1 		 | 制限時間 (3秒)
	bra	TTCPLUS
RWD4:	/* WD4 (eko-baggupuroguramu) の表示設定 */
	move.l	#WD4, %D2        	 | p  = #WD4
	move.l	#WD4, %a6
	move.l	#0x17, %D3        	 | size = 23
	move.l  #19, LEN_STR
	move.w  #45000, TCMP1 		 | 制限時間 (4.5秒)
	bra	TTCPLUS
RWD5:	/* WD5 (fukuokakenn) の表示設定 */
	move.l	#WD5, %D2        	 | p  = #WD5
	move.l	#WD5, %a6
	move.l	#0x0f, %D3      	 | size = 15
	move.l  #11, LEN_STR
	move.w  #35000, TCMP1 		 | 制限時間 (3.5秒)
	bra	TTCPLUS

CORRECT_OUT: /* "correct: " の表示設定 */
	move.l	#COMMENT1, %D2  	 | p  = #COMMENT1
	move.l	#0x0c,    %D3            | size = 12
	move.w  #1000, TCMP1             | TCMP = 1000 (0.1秒)
	bra	TTCPLUS

MISS_OUT: /* "miss: " の表示設定 */
	move.l	#COMMENT2, %D2        	 | p  = #COMMENT2
	move.l	#0x0c, %D3 
	move.w  #1000, TCMP1        	
	bra	TTCPLUS

CORRECT_NUM: /* 正解数の表示設定 */
	move.l	#CORRECT, %D2        	 | p  = #CORRECT (アスキーコードで格納)
	move.l	#0x01,    %D3    	 | size = 1
	move.w  #1000, TCMP1     
	bra	TTCPLUS


MISS_NUM: /* 誤り数の表示設定 */
	move.l	#MISS, %D2        	 | p  = #MISS (アスキーコードで格納)
	move.l	#0x01,    %D3    	 | size = 1
	move.w  #1000, TCMP1     
	bra	TTCPLUS

TTCPLUS:
	add	#2,%a6			 | A6 (期待文字列ポインタ) を \r\n の分だけ進める
	
	/* TCMP1 の値を更新し、タイマをリスタート */
	move.l	#SYSCALL_NUM_SET_TIMER, %D0
	move.l	#TT,    %D2
	trap	#0

	/* 文字列の送信 (PUTSTRING実行) */
	trap	#0			 

	addi.w	#1,TTC            	 | TTCカウンタを1つ増やす
	bra	TTEND                	 | 終了

CORRECT_PLUS:
	addi.b	#1,CORRECT               | CORRECT (正解数) をインクリメント
	bra	TTC_BRA

MISS_PLUS:
	addi.b	#1,MISS                  | MISS (誤り数) をインクリメント
	bra	TTC_BRA


TTKILL:
	move.l	#SYSCALL_NUM_RESET_TIMER,%D0
	trap	#0			| タイマを停止

TTEND:
	movem.l	(%SP)+,%D0-%D7/%A0-%A5	| 全レジスタ復帰
	rts

****************************************************************
**初期値のあるデータ領域
****************************************************************
.section .data
TMSG:
	.ascii	"******\r\n"      	 | タイトルメッセージ
	.even	                  	 
TTC:
	.dc.w	0			 | タイピングテストタスクの実行回数カウンタ
	.even
COUNTER:  				 | 入力できた文字数のカウント
	.dc.l   0
	.even
LEN_STR:  				 | 表示する文字列の長さ (期待される入力文字数)
	.dc.l   0
	.even
CORRECT:				 | 正解数 (アスキーコード '0' = 48 から開始を想定)
	.dc.b	48
	.even
MISS:					 | 誤り数 (アスキーコード '0' = 48 から開始を想定)
	.dc.b   48
	.even
WD1:
	.ascii	"\r\nkyushudaigaku\r\n"  		| 表示文字列1
	.even    
WD2:
	.ascii	"\r\ndennkijyouhoukougakuka\r\n"	| 表示文字列2
	.even      	
WD3:
	.ascii	"\r\nhyodo\r\n"				| 表示文字列3
	.even      	
WD4:
	.ascii	"\r\neko-baggupuroguramu\r\n"  		| 表示文字列4
	.even    	
WD5:
	.ascii	"\r\nfukuokakenn\r\n"  			| 表示文字列5
	.even    		 	

COMMENT1: .ascii "\r\n correct: "		| 正解表示用メッセージ
	  .even
COMMENT2: .ascii "\r\n    miss: "		| 誤り表示用メッセージ
	  .even
****************************************************************
**初期値の無いデータ領域
****************************************************************
.section .bss
BUF:
	.ds.b	256           		| I/O用バッファ領域
	.even

USR_STK:
	.ds.b	0x4000            	| ユーザスタック領域
	.even
USR_STK_TOP:			      	| ユーザスタック領域の最後尾